(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
      (print! (string-append "Test '" name "' failed")))))

;; empty?
(define empty? (lambda (ls) (eq? ls (list))))
(should-be "empty" (empty? (list 2)) #f)

;; boolean functions

(define not (lambda (x) (if x #f #t)))

(define and
  (lambda (x y)
    (if x y x)))

(should-be "and" (and #t #t) #t)
(should-be "and" (and #t #f) #f)
(should-be "and" (and #f #t) #f)
(should-be "and" (and #f #f) #f)

(define or
  (lambda (x y)
    (if x x y)))

(should-be "or" (or #t #t) #t)
(should-be "or" (or #t #f) #t)
(should-be "or" (or #f #t) #t)
(should-be "or" (or #f #f) #f)

(define all
  (lambda (xs) (foldr and #t xs)))

(should-be "all" (all '()) #t)
(should-be "all" (all '(#t)) #t)
(should-be "all" (all '(#f)) #f)
(should-be "all" (all '(#t #t #t #t)) #t)
(should-be "all" (all '(#t #t #f #t)) #f)

(define some
  (lambda (xs) (foldr or #f xs)))

(should-be "some" (some '()) #f)
(should-be "some" (some '(#t)) #t)
(should-be "some" (some '(#f)) #f)
(should-be "some" (some '(#f #f #f)) #f)
(should-be "some" (some '(#t #t #t #t)) #t)
(should-be "some" (some '(#t #t #f #t)) #t)

;; y-combinators

(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; List functions

(define length
  (lambda (xs)
    (foldr (lambda (x acc) (+ acc 1)) 0 xs)))

;; nil
(define nil (list))

;; reverse
(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range
(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; concat
(define concat (lambda (list1 list2)
  (foldr (lambda (a b) (cons a b)) list2 list1)))
(should-be "concat" (concat '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6))


;; filter
(define filter (Y2 (lambda (filter) (lambda (pred ls)
  (if (empty? ls)
      ls
  (if (pred (head ls))
      (cons (head ls) (filter pred (tail ls)))
      (filter pred (tail ls))))))))

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; dict functions

(define dict-from-list
  (lambda (xs)
    (foldr (lambda (kv acc) (insert (head kv) (head (tail kv)) acc)) (dict) xs)))

(should-be "dict-from-list"
           (dict-from-list (list (list :one 1) (list :two 2)))
           (dict :one 1 :two 2))

(define keys
  (lambda (d)
    (map head (seq d))))

;; Uncomment this test once map is fixed.
;; (should-be "keys"
;;            (keys (dict :one 1 :two 2))
;;            '(:one :two))

;; modify-ref
(define modify-ref
  (lambda (r fn)
    (write-ref r (fn (read-ref r)))))

;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict 'a 5))
  (dict 'a 6))

;; Lenses

;; Makes a lens out of a getter and a setter.
(define make-lens
  (lambda (g s)
    (dict 'getter g 'setter s)))

;; View a value through a lens.
(define view
  (lambda (lens target)
    ((lookup 'getter lens) target)))

;; Set a value though a lens.
(define set
  (lambda (lens new-view target)
    ((lookup 'setter lens) new-view target)))

;; identity lens
(define id-lens
  (make-lens
   (lambda (target) target)
   (lambda (new-view target) new-view)))

;; Compose lenses
(define ..
  (lambda (lens1 lens2)
    (make-lens
     (lambda (target) (view lens2 (view lens1 target)))
     (lambda (new-view target) (set lens1 (set lens2 new-view (view lens1 target)) target)))))

;; Compose many lenses
(define ... (lambda (lenses) (foldr .. id-lens lenses)))

;; Modify a value through a lens.
(define over
  (lambda (lens f target)
    (set lens (f (view lens target)) target)))

;; A lens targetting keys of dicts.
(define @
  (lambda (k)
    (make-lens (lambda (mp) (lookup k mp))
               (lambda (v mp) (insert k v mp)))))

(should-be "view lens"
           (view (@ :one) (dict :one 1 :two 2))
           1)

(should-be "set lens"
           (set (@ :two) 42 (dict :one 1 :two 2))
           (dict :one 1 :two 42))

(should-be "over lens"
           (over (@ :one) (lambda (x) (+ x 1)) (dict :one 1 :two 2))
           (dict :one 2 :two 2))

(should-be "lens composition"
           (over (.. (@ :a) (@ :b))
                 (lambda (x) (+ x 1))
                 (dict :a (dict :b 2)))
           (dict :a (dict :b 3)))

(do (define d
      (lambda (x) (dict :a (dict :b (dict :c x)))))
    (should-be "deep lenses"
               (over (... (list (@ :a) (@ :b) (@ :c)))
                     (lambda (x) (+ x 1))
                     (d 0))
               (d 1)))

;; Lens access to refs

(define view-ref
  (lambda (r lens)
    (view lens (read-ref r))))

(should-be "view-ref"
           (view-ref (ref (dict :key 1)) (@ :key))
           1)

(define set-ref
  (lambda (r lens v)
    (modify-ref r (lambda (x) (set lens v x)))))

(should-be "set-ref"
           (do (define r (ref (dict :a 1)))
               (set-ref r (@ :a) 2)
               (view-ref r (@ :a)))
           2)

(define over-ref
  (lambda (r lens f)
    (modify-ref r (lambda (x) (over lens f x)))))

(should-be "over-ref"
           (do (define r (ref (dict :a 2)))
               (over-ref r (@ :a) (lambda (x) (* x 2)))
               (view-ref r (@ :a)))
           4)

;; paper examples

(define sas-password "very secret")
(define sas-store (ref (dict)))
(define sas-eval-ref (ref eval))

;; self-amending key-val store
(define sas-starting-eval
  (lambda (expr)
    (define command (head expr))
    (cond
     (eq? command 'get) (lookup (nth 1 expr) (read-ref sas-store))
     (eq? command 'set) (modify-ref sas-store (lambda (s) (insert (nth 1 expr) (nth 2 expr) s)))
     (and (eq? command 'update)
          (eq? (nth 1 expr)
               sas-password))
     (write-ref sas-eval-ref (eval (nth 2 expr)))
     :else (throw 'invalid-command "Valid commands are: 'get', 'set' and 'update'."))))

;; Handle an input in the morphing state-machine.
(define state-machine-input
  (lambda (state i)
    (define upd (lambda (s) ((view-ref state (@ :transition-fn)) s i)))
    (over-ref state (@ :machine-state) upd)
    (print! (string-append "ACCEPTED! new state: " (show (view-ref state (@ :machine-state)))))))

;; Trigger a new vote
(define state-machine-new-trans
  (lambda (state func)
    (if (eq? (view-ref state (@ :voting)) :nothing)
        (do (set-ref state (@ :voting) (dict :votes (dict)
                                             :proposed-function func))
          (print! (string-append "A new transition function has been proposed! Please either agree or disagree with: " (show func))))
      (throw 'invalid-input "Can't propose new transition function while vote is ongoing."))))

(define state-machine-agree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (... (list (@ :voting) (@ :votes) (@ userid))) #t)
            (if (eq? (length (seq (view-ref state (.. (@ :voting) (@ :votes))))) (length voters))
                (do (set-ref state (@ :transition-fn) (eval (view-ref state (.. (@ :voting) (@ :proposed-function)))))
                    (set-ref state (@ :voting) :nothing)
                    (print! "Voting has finished; a new transition function is in effect."))
                '()))
        (throw 'invalid-input "Not allowed to vote."))))

(define state-machine-disagree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (@ :voting) :nothing)
            (print! "Voting has ended; someone disagreed."))
        (throw 'invalid-input "You are not allowed to vote."))))

;; Returns an eval which operates a state machine whose transition function may
;; be updated. To update the transition function all voters must agree on it.
(define state-machine-eval
  (lambda (voters init-state init-transition)
    (define state (ref (dict :machine-state init-state
                             :transition-fn init-transition
                             :voting :nothing)))
    (lambda (expr)
      (define verb (nth 0 expr))
      (define input (nth 1 expr))
      (cond
       (eq? verb 'input)          (state-machine-input     state input)
       (eq? verb 'new-trans-func) (state-machine-new-trans state input)
       (eq? verb 'agree)          (state-machine-agree     state voters input)
       (eq? verb 'disagree)       (state-machine-disagree  state voters input)))))

(define integer-machine
  (state-machine-eval (list "alice777" "bob_1337") 0 +))

(define discussion
  (state-machine-eval (list "james" "julian")
                      ""
                      (lambda (cur inp)
                        (string-append cur "\n\n" (head inp) ": " (head (tail inp))))))

(lambda (cur inp) (string-append cur "\n" (head inp) ": " (head (tail inp))))

;; (do (define eval-ref (ref eval)) (define eval (lambda (e) ((read-ref eval-ref) e))))

(define boom (quote (define eval (state-machine-eval '("alice" "bob") 0 +))))

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))

;; Chains

(define empty-state (dict
    :env (dict 'eval base-eval)
    :refs (list)))

(define empty-chain (dict
    :state empty-state
    :logs (list)))

(define chains (ref (dict "root" empty-chain)))

;; Updates chain and prints new results.

(define update-chain (lambda (chain-name)
  (define cur-chains (read-ref chains))
  (define this-chain (lookup chain-name cur-chains))
  (define new-logs
    (receive!
      chain-name
      (length (lookup :logs this-chain))))

  ;; Eval the chain. If it fails to eval we don't change the ref and thrown an
  ;; exception.
  (define eval-next (lambda (acc new-expr)
    (define eval-step (eval-with-env new-expr acc))
    (print! (head eval-step))
    (head (tail eval-step))))
  (define eval-result (foldl eval-next (lookup :state this-chain) new-logs))
  (define updated-chain
     (modify-map :logs (lambda (x) (concat x new-logs))
       (insert :state eval-result this-chain)))
  (write-ref chains (insert chain-name updated-chain cur-chains))))


;; The Repl

;; (define repl
;;   (dict
;;      'name "repl"
;;      ;; Parse errors are thrown here
;;      'getter (lambda () (catch 'parse-error (get-line!) print!))))
;;
;; (catch 'any
;;     (subscribe-to! repl print!)
;;     (lambda (x) (print! x) (subscribe-to! repl print!)))
